% $Id: $
%
%

\section{Prácticas: Introducción a Python}

%-----------------------    ---------------------------------
\usebackgroundtemplate{\includegraphics[width=13cm]{figs/yoda.jpg}}

\begin{frame}
\frametitle{Python}

\end{frame}
\usebackgroundtemplate{}


\subsection{Transparencias principales}

\begin{frame}
\frametitle{Transparencias principales}

\begin{center}
{\Huge Transparencias principales}

{\footnotesize (las que veremos en clase)}
\end{center}
\end{frame}


\begin{frame}[fragile]

\frametitle{Hola Mundo}

\begin{itemize}
\item Desde la shell, accede al intérprete de Python 3:

\begin{footnotesize}
\begin{verbatim}
$ python3
>>>
\end{verbatim}
\end{footnotesize}
\item Y ya podemos introducir instrucciones en Python:

\begin{footnotesize}
\begin{verbatim}
>>> print("hola mundo")
hola mundo
\end{verbatim}
\end{footnotesize}

\item A partir de ahora obviaremos los $>>>$ del intérprete.

\end{itemize}

\end{frame}



\begin{frame}[fragile]

\frametitle{Más ejemplos}


\begin{itemize}

\item Tenemos varios tipos de datos en Python

\begin{footnotesize}
\begin{verbatim}
print("Hello world")      # printing a string
euro = 22                 # integer
dollar = euro / 0.815563   # a float
print(str(euro) + " euro are "+ str(dolar) + " U.S. dollar")
\end{verbatim}
\end{footnotesize}

\item Las variables no se declaran

\item Dinámicamente tipado, pero fuertemente tipado

\item Python es sensible a mayúsculas

\item Los comentarios en línea empiezan por \verb=#=

\item En Python todo es un objeto

\end{itemize}


\end{frame}


\begin{frame}[fragile]
\frametitle{Cadenas (strings)}

\begin{itemize}
\item No existe tipo \verb|char|

\begin{footnotesize}
\begin{verbatim}
print("hi")     # double quotes
print('hi')     # single quotes

print('she said \'hi\'')  # booooo! this is ugly!
print('she said "hi"')    # looks better

print("Oye\n¿cómo va? Mi ritmo") # contains special characters

print(b"These are bytes, not a string") # You've got to convert it to string!
str(b"These are bytes", 'utf-8')
\end{verbatim}
\end{footnotesize}

\item El operador \verb|+| concatena cadenas, y el \verb|*| las repite
  un número entero de veces
\end{itemize}
\end{frame}



\begin{frame}[fragile]
\frametitle{Operaciones sobre cadenas}

\begin{itemize}
\item \verb|a_string.join(a_list_of_strings)| devuelve una cadena que engloba a todos los elementos de la lista.\\
\item \verb|a_string.split()| devuelve una lista dividiendo una cadena\\
\item \verb|a_string.upper()| y \verb|a_string.lower()| devuelve la cadena en mayúsculas/minúsculas\\
\end{itemize}

Estas funciones de biblioteca, como todas, podemos encontrarlas
en la \emph{python library reference}: 
https://docs.python.org/3/library/index.html

\end{frame}

\begin{frame}[fragile]
\frametitle{¡Calentando! Ejercicio \#0}  

Crea un script en Python en consola, que:

\begin{itemize}
  \item Cree una cadena
  \item Cree un entero
  \item Cree un float
  \item Multiplique el entero por el float
  \item Cree una cadena de bytes
  \item Concatene la cadena con los bytes
\end{itemize}
\end{frame}



\begin{frame}[fragile]
\frametitle{Errores en Python}  
\begin{itemize}
  
\item El intérprete puede lanzar un error (y acabar)
\item Hay familias de errores (p.ej., SyntaxError)
\item El intérprete te dará una pista de dónde puede estar el error:

\begin{footnotesize}
\begin{verbatim}

while True print('Hello world')
File "<stdin>", line 1
  while True print('Hello world')
            ^
SyntaxError: invalid syntax

\end{verbatim}
\end{footnotesize}

\item Los errores se pueden \emph{capturar} con excepciones (que veremos en breve, no seáis impacientes)

\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Funciones predefinidas (\emph{built-in})}  

\begin{itemize}
  \item \verb|float()|  convierte a float
  \item \verb|int()|  convierte a int
  \item \verb|str()|  convierte a string
  \item \verb|bytes()| convierte a bytes
  \item \verb|round()|  redondea
  \item \verb|abs()|   valor absoluto
  \item \verb|input()|  acepta un valor desde teclado
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{Ejercicio \#1}  

Crea un script en Python en el intérprete que...

\begin{itemize}
  \item Tome dos valores de entrada
  \item y los sume...
  \item (¡dando el resultado correcto!)
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Listas}

\begin{itemize}
\item Tipo de datos predefinido en Python, va mucho más allá de los
  arrays
\item Es un conjunto {\bf indexado} de elementos, no necesariamente homogéneos
\item Sintaxis: Identificador de lista, mas índice entre corchetes
\item Cada elemento se separa del anterior por un caracter \verb|,|
\end{itemize}
  \begin{footnotesize}
\begin{verbatim}
colors = ['red', 'yellow']
colors.append('green')
print(colors)
print(colors[2])
print(len(colors))

things = ['string', 2, 3.0]

\end{verbatim}
  \end{footnotesize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Más sobre listas}

\begin{itemize}
\item El primer elemento tiene índice 0.
\item Un índice negativo accede a los elementos empezando por el final
  de la lista. El último elemento tiene índice -1.
\item Pueden referirse {\bf rodajas} (\emph{slices}) de listas
  escribiendo dos índices entre el caracter \verb|:|
\item La rodaja va desde el {\bf primero, incluido}, al {\bf último,
    excluido}.
\item Si no aparece el primero, se entiende que empieza en el primer
  elemento (0)
\item Si no aparece el segundo, se entiende que termina en el último
  elemento (incluido). 
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Ejemplos de listas}

  \begin{footnotesize}
\begin{verbatim}
a_list = [0, 1, 2, 3, 4]
print(a_list)      # [0, 1, 2, 3, 4]
print(a_list[1])   # 1 
print(a_list[0:2]) # [0, 1]
print(a_list[3:])  # [3, 4]
print(a_list[-1])  # 4
print(a_list[:-1]) # [0, 1, 2, 3]
print(a_list[:-2]) # [0, 1, 2]
\end{verbatim}
  \end{footnotesize}
  \begin{center}
¡La misma sintaxis se aplica a las cadenas!
  \end{center}

  \begin{footnotesize}
\begin{verbatim}
a_string = "tortilla"
print(a_string[-1])
\end{verbatim}
  \end{footnotesize}


\end{frame}


\begin{frame}[fragile]
\frametitle{Sangrado y separadores de sentencias}

\begin{itemize}
\item ¡En Python no hay llaves ni \verb|begin-end| para encerrar bloques
  de código!
\item Un mayor nivel de sangrado indica que comienza un bloque,
  y un menor nivel indica que termina un bloque.

\begin{footnotesize}
\begin{verbatim}
integer = 3
if integer:
     print('true')
else:
     print('false')
\end{verbatim}
\end{footnotesize}


  \item Para enteros: todo lo que no sea cero es True
  \item Nótese como el caracter \verb|:| introduce cada bloque de sentencias. Si hay \verb|:|, entonces la siguiente línea estará indentada.
\end{itemize}
\end{frame}



\begin{frame}[fragile]

\frametitle{Bucles}
Un bucle \verb|for| (\emph{foreach} en Java):

\begin{footnotesize}
\begin{verbatim}
for item_variable in iterable_variable:
    pass     # really, do something here.
             # Usually with the item_variable

\end{verbatim}
\end{footnotesize}

Ejemplo \emph{real}:

\begin{footnotesize}
\begin{verbatim}
friends = ['ana', 'jacinto', 'guillermo', 'jennifer']
for invited in friends:
...  print(invited, len(invited))
... 
ana 3
jacinto 7
guillermo 9 
jennifer 8
\end{verbatim}
\end{footnotesize}

\end{frame}




\begin{frame}[fragile]
\frametitle{Ejercicio \#2}  

Crea un script en Python en la consola que...

\begin{itemize}
  \item Cree una lista con todos los días de la semana ('Lun', 'Mar'...)
  \item Imprima sólo los que son días laborales (en tres líneas... o incluso dos)
  \item Imprima sólo los que tengan al menos una 'a'
\end{itemize}


\end{frame}





\begin{frame}[fragile]
\frametitle{Diccionarios}  

\begin{itemize}
\item Es un conjunto {\bf desordenado} de elementos 
\item Cada elemento del diccionario es un par clave-valor. 
\item Se pueden obtener valores a partir de la clave, pero no al revés.
\item Longitud variable
\item Elementos heterogéneos
\item Hace las veces de los \emph{registros} en otros lenguajes
\item Atención: Se declaran con \verb|{}|, se refieren con \verb|[]|
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Más sobre diccionarios}
  \begin{footnotesize}
\begin{verbatim}
countries = {'de': 'Germany', 'fr': 'France', 'es': 'Spain'}
print(countries); print(countries["fr"])

extensions = {}
extensions['py'] = 'python'
extensions['txt'] = 'plain text'
extensions['ps'] = 'PostScript'

for tld in countries: # iterating through the dictionary
   print(country, countries[tld])

del countries['fr']   # removes the key (and its value)
print(len(countries)) # returns the number of elements in the dict
countries.clear()  # removes all entries in the dictionary

\end{verbatim}
  \end{footnotesize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Utilizando un editor o un IDE (I)}

\begin{itemize}
  \item Usar el intérprete de Python para programar es tedioso
  \item Es mejor utilizar cualquier editor de texto (p.ej., gedit) o un IDE (como Eclipse, Atom...)
  \item Lo que crearemos son ficheros de texto plano.
\end{itemize}

\begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3

print("¡Hola Mundo!")

\end{verbatim}
\end{footnotesize}

\end{frame}


\begin{frame}[fragile]
\frametitle{Utilizando un editor o un IDE (y II)}


\begin{itemize}
  \item Si lo guardamos como hola.py, se ejecuta desde la línea de comandos como:
\begin{footnotesize}
\begin{verbatim}
$ python3 hola.py
\end{verbatim}
\end{footnotesize}

  \item Podemos darle permisos de ejecución al fichero:
\begin{footnotesize}
\begin{verbatim}
$ chmod +x hola.py
\end{verbatim}
\end{footnotesize}

  \item Y entonces, se ejecuta desde la línea de comandos como:
\begin{footnotesize}
\begin{verbatim}
$ ./hola.py
\end{verbatim}
\end{footnotesize}


  
\end{itemize}

\end{frame}




\begin{frame}[fragile]
\frametitle{Ejercicio \#3}  

Crea un script en Python en tu IDE que...

\begin{itemize}
  \item Cree un diccionario con cinco entradas: 
  \begin{itemize}
    \item las llaves son las palabras en inglés
    \item los valores su traducción al español
  \end{itemize}
  \item Imprima todas las duplas llave-valor en un bucle
\end{itemize}

\end{frame}




\begin{frame}[fragile]
\frametitle{Usando bibliotecas (módulos)}

\begin{itemize}
\item Python viene con las baterías incluidas
\item Hay muchos módulos (estándar) que vienen con la biblioteca estándar
\item (Y podemos instalar muchos más módulos externos)
\item Al importar un módulo, importamos su fucionalidad (clases, funciones, variables) \\

\item Si quieres funcionalidad de tiempo, usa \emph{time}

  \begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
import time
time.time()    # Gives the seconds since Jan 1st 1970
\end{verbatim}
  \end{footnotesize}
  
 \item Mira la documentación de la \emph{Python library reference}.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Usando bibliotecas (y II)}
  

\begin{itemize}


\item Si quieres hacer cálculos, usa \emph{math}

  \begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
import math
radius = 2
circumference = 2 * math.pi * radius    # math.pi is a variable
area = 5
radius = math.sqrt(area / math.pi)     # math.sqrt is a function
\end{verbatim}
\end{footnotesize}
 

\item Si quieres coger parámetros desde la línea de \emph{shell}, usa la lista \emph{argv} de \emph{sys}

  \begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
import sys
print(sys.argv[1:])
\end{verbatim}
  \end{footnotesize}
  
\end{itemize}
  
\end{frame}



\begin{frame}[fragile]
\frametitle{Ejercicio \#4}  

Crea un script Python que...

\begin{itemize}
  \item Tome como entrada el nombre de usuario de Twitter 
  \item Se descargue la página de twitter del usuario
  \item Imprima la página
  \item Avanzado: ¿podrías imprimirla en bonito?
  \item Pista: Mira en urllib.request
\end{itemize}

\end{frame}


\begin{frame}[fragile]
\frametitle{Importar módulos}

Hay varias maneras:

\begin{itemize}
\item \verb|import nombre-módulo               | \\permite acceder a los
  símbolos del módulo con la sintaxis \verb|nombre-módulo.X|
\item \verb|from nombre-módulo import a, b, c  | \\incorpora
  los símbolos a, b, c al espacio de nombres, siendo accesibles
  directamente (sin cualificarlos con el nombre del módulo)
\item \verb|from nombre-módulo import *        | \\incorpora los
  símbolos del módulo al espacio de nombres, siendo accesibles
  directamente (sin cualificarlos con el nombre del módulo). No recomendada.
\end{itemize}
\end{frame}




\begin{frame}[fragile]
\frametitle{Ficheros}
\begin{itemize}
  
\item \verb|open(nombre_fichero,modo)| devuelve un objeto fichero (fd)

modo:
\begin{itemize}
  
\item \verb|w|: Escritura. Destruye contenido anterior
\item \verb|r|: Lectura. Modo por defecto
\item \verb|r+|: Lectura y Escritura
\item \verb|a|: Append

\end{itemize}

\item \verb|fd.write(string)| escribe la cadena en el fichero  
\item \verb|fd.read()| devuelve el contenido del fichero
\item \verb|fd.readline()| devuelve la siguiente línea del fichero
\item \verb|fd.readlines()| devuelve una lista con cada línea del fichero
\item \verb|fd.close()| cierra el fichero

\end{itemize}

La apertura y cierre de un fichero pueden meterse en un \emph{contexto} con \emph{with}
\end{frame}


\begin{frame}[fragile]
\frametitle{Ejemplos de uso de ficheros}

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
myfile = open('/tmp/test', 'w')
myfile.write("Monday\n")
myfile.close()

myfile = open('/tmp/test', 'a')
myfile.write("Tuesday\n")
myfile.close()

myfile = open('/etc/hosts', 'r')
machines = myfile.readlines()
fich.close()

for machine in machines:
    print(machine)

\end{verbatim}
\end{footnotesize}
\end{frame}



\begin{frame}[fragile]
\frametitle{Ejercicio \#5}  

Crea un script en Python que...

\begin{itemize}
  \item Abra el fichero \emph{/etc/passwd}
  \item Tome el nombre de usuario y su respectiva \emph{shell}
  \item Lo imprima por pantalla
\end{itemize}

\end{frame}




\begin{frame}[fragile]
\frametitle{Funciones / Métodos / Definiciones}

\begin{itemize}
\item Las funciones se definen con \emph{def} (y se usa identación):
\end{itemize}

  \begin{footnotesize}
\begin{verbatim}
# An example of two Python functions
def to_cent(faren):
    """Converts Fahrenheit to Celsius - Docstring comment"""
    return (faren - 32) * (5.0/9)

def to_faren(cels):
    """Converts Celsius to Fahrenheit"""
    return (cels * 1.8) + 32
\end{verbatim}
  \end{footnotesize}

\end{frame}



\begin{frame}[fragile]
\frametitle{El atributo \_\_name\_\_ de un módulo}

Los módulos son objetos, con ciertos atributos predefinidos.

El atributo \verb|__name__|:
\begin{itemize}
  \item si el módulo es importado (con \verb|import|), contiene el
  nombre del fichero, sin trayecto ni extensión
  \item si el módulo es un programa que se ejecuta sólo, contiene el
  valor \verb|__main__|
\end{itemize}

Puede escribirse ejecución condicionada a cómo se use el módulo:
\begin{footnotesize}
\begin{verbatim}
if __name__ == "__main__": 
    ...
\end{verbatim}
\end{footnotesize}
  
\end{frame}







\begin{frame}[fragile]
\frametitle{Un programa en Python}

\begin{footnotesize}
\begin{verbatim}
def sum(sumando1, sumando2):
    """Sums two integer/floats

    Returns integer/float."""

    return sumando1 + sumando2

if __name__ == "__main__":
    first = int(input("Please enter an integer/float: "))
    second = int(input("Please enter another integer/float: "))
    print(sum(first, second)) 

\end{verbatim}
\end{footnotesize}

Ejecución:
\begin{footnotesize}
\begin{verbatim}
    $ python3 suma.py
\end{verbatim}
\end{footnotesize}
 
\end{frame}


\begin{frame}[fragile]
\frametitle{Ejercicio \#6}  

Crea un script en Python que...

\begin{itemize}
  \item Haga lo mismo que el ejercicio \#5
  \item Pero con un \_\_main\_\_
\end{itemize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Excepciones}
\begin{itemize}
\item Un programa sintácticamente correcto puede dar errores de ejecución
\end{itemize}

  \begin{footnotesize}
\begin{verbatim}

#!/usr/bin/python3
while 1:
    x=int(input("Give me a number"))
    print(x)

\end{verbatim}
  \end{footnotesize}

\end{frame}




\begin{frame}[fragile]
\frametitle{Excepciones (y II)}

\begin{itemize}
\item  Definimos una acción para determinada excepción
\end{itemize}

  \begin{footnotesize}
\begin{verbatim}

#!-/usr/bin/python3
while 1:
    try:
        x=int(input("Introduce un nº:"))
        print(x)
    except ValueError:
        print("Número incorrecto")

\end{verbatim}
  \end{footnotesize}


\end{frame}



\begin{frame}[fragile]
\frametitle{Excepciones (y III)}

\begin{itemize}
\item Se puede indicar una acción para cualquier excepción\\
      pero es \emph{muy} desaconsejable (enmascara otros errores)
\item  El programador puede levantar excepciones
\end{itemize}

  \begin{footnotesize}
\begin{verbatim}

#!-/usr/bin/python3
try:
    x=int(input("Give me a number:"))
    print(x)
except:     # for anything that is not a number. Not recommended!
    print("Hey, this was not a number")

raise SystemExit
print("this never runs")
\end{verbatim}
  \end{footnotesize}


\end{frame}




\begin{frame}[fragile]
\frametitle{Ejercicio \#7}  

Crea un script en Python que...

\begin{itemize}
  \item Haga lo que hacíamos en el ejercicio \#6
  \item Y nos de exclusivamente la shell de los usuario \emph{root} e \emph{imaginario}
  \item Añada excepciones
\end{itemize}

\end{frame}




\begin{frame}[fragile]
\frametitle{PEP 8 (Python Enhancement Proposal \#8)}

\begin{itemize}
  \item Guía de estilo para programar en Python
  \item Es (todavía) más estricta que el propio intérprete
  \item Mejora la legibilidad y mantenibilidad del código
  \item Parcialmente, se puede comprobar con \texttt{pep8}
\begin{footnotesize}
\begin{verbatim}
$ pep8 pepe.py
pepe.py:248:30: E225 missing whitespace around operator
pepe.py.py:248:80: E501 line too long (97 > 79 characters)
[...]
\end{verbatim}
\end{footnotesize}
\end{itemize}
\end{frame}


\subsection{Consideraciones adicionales}

\begin{frame}[fragile]
\frametitle{Consideraciones adicionales}

\begin{center}
{\Huge Consideraciones Adicionales}

{\footnotesize (transparencias de referencia)}

\end{center}


\end{frame}


\begin{frame}[fragile]
\frametitle{Ámbito de las variables}
\begin{itemize}
\item 
Las variable declaradas fuera de una función son globales
\end{itemize}
%01
%    """Ejemplo para hablar del ámbito"""
  \begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3
numero = 5
def f(parametro):
    return parametro + numero
print(f(3))    # 8
\end{verbatim}
  \end{footnotesize}

\begin{itemize}
\item 
Las variable declaradas dentro de una función son locales
\end{itemize}

%02
  \begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3
def f(parametro):
    numero = 5
    return parametro + numero
print(f(3))
print(numero)    # ERROR: numero es de ambito local
\end{verbatim}
  \end{footnotesize}


\end{frame}


\begin{frame}[fragile]
\frametitle{Más sobre ámbito de variables}

\begin{itemize}
\item 
Dentro de una función se puede ver una variable global\\
pero no modificar
\end{itemize}
%03
  \begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3
numero = 5
def f(parametro):
    numero = numero - 1    #ERROR: no se puede modificar variable global
    return paramentro + numero
    
print(f(3))
\end{verbatim}
  \end{footnotesize}

\begin{itemize}
\item 
A menos que se use la sentencia \verb|global|
\end{itemize}



 %04 
  \begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3
numero = 5
def f(parametro):
    global numero   # permite modificar una variable global
    numero = numero - 1   
    return parametro + numero
print(f(3))    # 7
print(numero)  # 4
\end{verbatim}
  \end{footnotesize}


\end{frame}

\begin{frame}[fragile]
\frametitle{Más sobre ámbito de variables}
\begin{itemize}
  
\item  Un poco más complicado:

\end{itemize}


  \begin{footnotesize}
 %06 
\begin{verbatim}
#!/usr/bin/python3
numero = 5
def f(parametro):
    numero = 4   # ahora numero es variable local
    return parametro + numero
    
print(f(3))   # 7
print(numero) # 5

\end{verbatim}
  \end{footnotesize}

\end{frame}




\begin{frame}
\frametitle{Definición de variables}

Python es
\begin{itemize}
\item fuertemente tipado (frente a débilmente tipado)
\item sensible a mayúsculas/minúsculas
\end{itemize}



En Python la declaración de variables es implícita \\(no hay declaración explícita)
\begin{itemize}
\item Las variables ``nacen'' cuando se les asigna un valor
\item Las variables ``desaparecen'' cuando se sale de su ámbito
\end{itemize}  
\end{frame}


\begin{frame}[fragile]
\frametitle{Sangrado y separadores de sentencias (II)}

\begin{itemize}
\item Las sentencias se terminan al acabarse la línea (salvo casos
  especiales donde la sentencia queda ``abierta'': en mitad de
  expresiones entre paréntesis, corchetes o llaves).
  
\item El caracter \verb|\| se utiliza para extender una sentencia más
  allá de una linea, en los casos en que no queda ``abierta''. 

\item El caracter \verb|:| se utiliza como separador en sentencias
  compuestas. Ej.: para separar la definición de una función de su
  código.
  
\item El caracter \verb|;| se utiliza como separador de sentencias
  escritas en la misma línea.

\end{itemize}
\end{frame}




\begin{frame}[fragile]
\frametitle{Tuplas}

Tipo predefinido de Python para una lista inmutable.

Se define de la misma manera, pero con los elementos entre paréntesis.

Las tuplas no tienen métodos: no se pueden añadir elementos, ni
cambiarlos, ni buscar con \verb|index()|.

Sí puede comprobarse la existencia con el operador \verb|in|.


\begin{footnotesize}
\begin{verbatim}
>>> tupla = ("a", "b", "mpilgrim", "z", "example") 
>>> tupla[0]                                       
'a'
>>> 'a' in tupla
1
>>> tupla[0] =  "b"
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
TypeError: object doesn't support item assignment
\end{verbatim}
\end{footnotesize}

  
\end{frame}



\begin{frame}[fragile]

Utilidad de las tuplas:
\begin{itemize}
\item Son más rápidas que las listas
\item Pueden ser una clave de un diccionario (no así las listas)
\item Se usan en el formateo de cadenas
\end{itemize} 

\verb|tuple(lista)| devuelve una tupla con los elementos de la lista \verb|lista|

\verb|list(tupla)| devuelve una lista con los elementos de la tupla \verb|tupla|

\end{frame} 










\begin{frame}[fragile]
  \begin{center}
\frametitle{Operadores }
En orden de precedencia decreciente:
  \end{center}
  

  \begin{footnotesize}
\begin{verbatim}
  +x, -x, ~x    Unary operators
  x ** y    Power 
  x * y, x / y, x % y    Multiplication, division, modulo
  x + y, x - y    Addition, subtraction
  x << y, x >> y    Bit shifting
  x & y    Bitwise and
  x | y    Bitwise or
  x < y, x <= y, x > y, x >= y, x == y, x != y,
  x <> y, x is y, x is not y, x in s, x not in s  
                         Comparison, identity, 
                         sequence membership tests
  not x     Logical negation
  x and y    Logical and
  lambda args: expr            Anonymous function
\end{verbatim}
  \end{footnotesize}

\end{frame}

\begin{frame}[fragile]

\begin{itemize}
  
\item 
La declaración implícita de variables como en perl puede provocar resultados desastrosos
\end{itemize}

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/perl
$sum_elementos= 3 + 4 + 17;
$media=suma_elementos / 3;    # deletreamos mal la variable
print($media;)   # y provocamos resultado incorrecto
\end{verbatim}
\end{footnotesize}

\begin{itemize}
\item 
Pero Python no permite referenciar variables a las que nunca se ha
asignado un valor.
\end{itemize}
\begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3
sum_elementos = 3 + 4 + 17
media = suma_elementos / 3    # deletreamos mal la variable
print(media)   # y el compilador nos avisa con un error
\end{verbatim}
\end{footnotesize}
adi

\end{frame}






\begin{frame}[fragile]

\frametitle{Más sobre cadenas}  

  \begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3

cadena = "más vale pájaro en mano"
print(cadena.split())
print(cadena.upper())

otra_cadena = "que,cocodrilo,en,tobillo"
print(otra_cadena.split(','))

lista = ['rojo', 'amarillo', 'verde']
print(lista.join())

\end{verbatim}
  \end{footnotesize}



  
\end{frame}

\begin{frame}[fragile]
\frametitle{Operaciones sobre diccionarios}

\begin{footnotesize}
  \begin{itemize}
  \item \verb|len(d)        | devuelve el número de elementos de \verb|d|
  \item \verb|d.has_key(k)  | devuelve 1 si existe la clave \verb|k| en
    \verb|d|, 0 en caso contrario
  \item \verb|k in d        | equivale a: \verb|    d.has_key(k)|
  \item \verb|d.items()     | devuelve la lista de elementos de \verb|d|
  \item \verb|d.keys()      | devuelve la lista de claves de \verb|d|
%  \item \verb|d1.update(d2) | equivale a: \verb|    for k in d2.keys(): d1[k] = d2[k]|
%  \item \verb|d.get(k,v)    | devuelve el valor de clave \verb|k| si
%    existe, \verb|v| en caso contrario
  \end{itemize}
\end{footnotesize}
\end{frame}




%\begin{frame}[fragile]

%\begin{itemize}
%\item El operador \verb|%| permite hacer formateo de cadenas (al estilo
%  de \verb|sprintf| en C) apoyándose en tuplas:

%\begin{footnotesize}
%\begin{verbatim}
%>>> uid = "sa"
%>>> pwd = "secret"
%>>> print(pwd + " is not a good password for " + uid)      
%secret is not a good password for sa
%>>> print("%s is not a good password for %s" % (pwd, uid)) 
%secret is not a good password for sa
%>>> userCount = 6
%>>> print("Users connected: %d" % (userCount, ))           
%Users connected: 6
%>>> print("Users connected: " + userCount)          
%Traceback (innermost last):
%  File "<interactive input>", line 1, in ?
%TypeError: cannot add type "int" to string
%\end{verbatim}
%\end{footnotesize}
%
%\end{itemize}  

%\end{frame}




\begin{frame}[fragile]
\frametitle{Recogiendo datos del usuario con raw\_input}

\begin{footnotesize}
\begin{verbatim}
#!-/usr/bin/python3
entero = int(raw_input("Please enter an integer: "))
if entero < 0:
     entero = 0
     print('Negative changed to zero')
elif entero == 0:
     print('Zero')
elif entero == 1:
     print('Single')
else:
     print('More')
\end{verbatim}
\end{footnotesize}
  

No existe \verb|switch/case|
\end{frame}














\begin{frame}[fragile]
\frametitle{Más sobre listas}

\begin{itemize}
\item \verb|append()| añade un elemento al final de la lista
\item \verb|insert()| inserta un elemento en la posición indicada
\end{itemize}  

\begin{footnotesize}
\begin{verbatim}
>>> lista
['a', 'b', 'mpilgrim', 'z', 'example']
>>> lista.append("new")               
>>> lista
['a', 'b', 'mpilgrim', 'z', 'example', 'new']
>>> lista.insert(2, "new")           
>>> lista
['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new']
\end{verbatim}
\end{footnotesize}


\end{frame}



\begin{frame}[fragile]
\frametitle{Más sobre listas}

\begin{itemize}
\item \verb|index()| busca en la lista un elemento y devuelve el
  índice de la primera aparición del elemento en la lista. Si no
  aparece se eleva una excepción.
\item El operador \verb|in| devuelve 1 si un elemento aparece en la
  lista, y 0 en caso contrario.
\end{itemize}

\begin{footnotesize}
\begin{verbatim}
>>> lista
['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new']
>>> lista.index("example") 
5
>>> lista.index("new")     
2
>>> lista.index("c")       
Traceback (innermost last):
  File "<interactive input>", line 1, in ?
ValueError: list.index(x): x not in list
>>> "c" in lista           
0
\end{verbatim}
\end{footnotesize}

\end{frame}




\begin{frame}[fragile]
\frametitle{Más sobre listas}

\begin{itemize}
\item \verb|remove()| elimina la primera aparición de un elemento en
  la lista. Si no aparece, eleva una excepción.
\item \verb|pop()| devuelve el último elemento de la lista, y lo elimina. (Pila) 
\item \verb|pop(0)| devuelve el primer elemento de la lista, y lo elimina. (Cola)
\end{itemize}

\begin{footnotesize}
\begin{verbatim}
 >>> lista
 ['patatas', 'bravas', 'alioli', 'huevo', 'tortilla', 'chorizo']
>>> lista.remove("alioli") 
>>> lista
['patatas', 'bravas', 'huevo', 'tortilla', 'chorizo']
>>> lista.remove("oreja")   
Traceback (innermost last):
  File "<interactive input>", line 1, in ?
ValueError: list.remove(x): orija not in list
>>> lista.pop()         
'chorizo'
>>> lista
 ['patatas', 'bravas', 'alioli', 'huevo', 'tortilla']
\end{verbatim}
\end{footnotesize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Más sobre listas}

\begin{itemize}
\item El operador \verb|+| concatena dos listas, devolviendo una nueva
  lista
\item El operador \verb|*| concatena repetitivamente una lista a sí
  misma
\end{itemize}

\begin{footnotesize}
\begin{verbatim}
>>> lista = ['patatas', 'bravas', 'alioli']
>>> lista = lista + ['huevo', 'tortilla'] 
>>> lista
['patatas', 'bravas', 'alioli', 'huevo', 'tortilla']
>>> lista += ['chorizo']                
>>> lista
['patatas', 'bravas', 'alioli', 'huevo', 'tortilla', 'chorizo']
>>> lista = [1, 2] * 3              
>>> lista
[1, 2, 1, 2, 1, 2]
\end{verbatim}
\end{footnotesize}



\end{frame}



\begin{frame}[fragile]
\frametitle{Más sobre listas}

\begin{itemize}
\item \verb|sort()| ordena una lista. Puede recibir opcionalmente un
  argumento especificando una función de comparación, lo que enlentece
  notable su funcionamiento
\item \verb|reverse()| invierte las posiciones de los elementos en una
  lista.
\end{itemize}
Ninguno de estos métodos devuelve nada, simplemente alteran la lista
sobre la que se aplican.
\begin{footnotesize}
\begin{verbatim}
>>> li = ['a', 'b', 'new', 'mpilgrim', 'z', 'example', 'new', 'two', 'elements']
>>> li.sort() 
>>> li
['a', 'b', 'elements', 'example', 'mpilgrim', 'new', 'new', 'two', 'z']
>>> li.reverse()
>>> li
['z', 'two', 'new', 'new', 'mpilgrim', 'example', 'elements', 'b', 'a']
\end{verbatim}
\end{footnotesize}

\end{frame}










\begin{frame}[fragile]
\frametitle{Asignaciones múltiples y rangos}

\begin{itemize}
\item Pueden hacerse también tuplas de variables:
\begin{footnotesize}
\begin{verbatim}
>>> tupla = ('a', 'b', 'e')
>>> (primero, segundo, tercero) = tupla
>>> primero
'a'
\end{verbatim}
\end{footnotesize}

\item La función \verb|range()| permite generar listas al vuelo:
\begin{footnotesize}
\begin{verbatim}
>>> range(7)
[0, 1, 2, 3, 4, 5, 6]
>>> (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, 
... FRIDAY, SATURDAY, SUNDAY) = range(7)
>>> MONDAY
0
>>> SUNDAY
6
\end{verbatim}
\end{footnotesize}
\end{itemize}

\end{frame}



\begin{frame}[fragile]
\frametitle{Mapeo de listas}

\begin{itemize}
\item Se puede mapear una lista en otra, aplicando una función a cada
  elemento de la lista:
  \begin{footnotesize}
\begin{verbatim}
>>> li = [1, 9, 8, 4]
>>> [elem*2 for elem in li]      
[2, 18, 16, 8]
>>> li                           
[1, 9, 8, 4]
>>> li = [elem*2 for elem in li] 
>>> li
[2, 18, 16, 8]
\end{verbatim}
  \end{footnotesize}
\end{itemize}
  
\end{frame}


\begin{frame}[fragile]
\frametitle{Filtrado de listas}
\begin{itemize}
\item Sintaxis:
\begin{footnotesize}
\begin{verbatim}
[expresión-mapeo for elemento in lista-orig if condición-filtrado]
\end{verbatim}
\end{footnotesize}
\item Ejemplos:
\begin{footnotesize}
\begin{verbatim}
>>> li = ["a", "mpilgrim", "foo", "b", "c", "b", "d", "d"]
>>> [elem for elem in li if len(elem) > 1]       1
['mpilgrim', 'foo']
\end{verbatim}
\end{footnotesize}

\end{itemize}
 
\end{frame}








\begin{frame}[fragile]
 
\frametitle{Control de flujo}
Sentencia \verb|while|:
\begin{footnotesize}
\begin{verbatim}
>>> a, b = 0, 1
>>> while b < 1000:
...     print(b),
...     a, b = b, a+b
... 
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
\end{verbatim}
\end{footnotesize}
Nótese el efecto de un caracter \verb|,| al final de un \verb|print()|

Nótese otro modelo de asignación múltiple 

\end{frame}


\begin{frame}[fragile]

\begin{itemize}
  
\item 
\verb|break| sale de un bucle:
\end{itemize}

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
a=10
while a > 0:
    print(a),
    a=a-1

\end{verbatim}
\end{footnotesize}

equivale a 

\begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
a=10
while 1:
    print(a),
    if a==1:
        break
    a=a-1
\end{verbatim}
\end{footnotesize}
\end{frame}




\begin{frame}[fragile]
\frametitle{Uso de bibliotecas}



\begin{itemize}
\item  Llamada al shell
\end{itemize}


  \begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
import os
os.system('ls -l')
\end{verbatim}
  \end{footnotesize}

\begin{itemize}
\item Argumentos de linea de comandos
\end{itemize}



  \begin{footnotesize}
\begin{verbatim}
#!/usr/bin/python3
import sys
print(sys.argv[1:])

\end{verbatim}
  \end{footnotesize}
Las funciones de biblioteca podemos encontrarlas
en la \\\emph{python library reference}
(disponible en el web en muchos formatos)
\end{frame}






%\begin{frame}
%\frametitle{Persistencia en Python}
%Persistencia en Python: La biblioteca \emph{Pickle}

%Serializa Objetos

%Permite:
%  \begin{itemize}
%\item Transmitir objetos, almacenarlos en Disco ó SGBD
%\item Soporte Referencias recursivas
%\item Compartir objetos
%\item Clases definidas por el usuario y sus instancias
%  \end{itemize}
%\end{frame}



%\begin{frame}[fragile]

%  \begin{footnotesize}
%\begin{verbatim}
%#!-/usr/bin/python3
%import pickle

%cp={28:'madrid',08:'barcelona',33:'asturias'}
%fich=open('/tmp/prueba.pick','w')
%pickle.dump(cp,fich)
%fich.close()

%fich=open('/tmp/prueba.pick','r')
%codigos_postales=pickle.load(fich)
%fich.close()

%for x in codigos_postales.keys():
%    print(x,codigos_postales[x])

%\end{verbatim}
%  \end{footnotesize}


%\end{frame}



%\begin{frame}
%Limitaciones de la Persistencia de Python:
%  \begin{itemize}
%  \item Lenta
%  \item Secuencial
%  \item Sin nombrado persistente
%  \item Sin acceso concurrente a objetos
%  \end{itemize}
%\end{frame}


%\begin{frame}
%Persistencia en Python mediante ZODB

%Aspecto Fundamental: Transacción

%Semántica distinta a la habitual
%  \begin{itemize}
%  \item Sub-Transacción: "La de siempre"
%  \item Transacción: Se actualiza en la BD todo
%  lo que haya cambiado desde determinado instante.
%Intervalo típico: Una sesión de trabajo
%  \item Versión: Para periodo de tiempo muy amplio
%  \end{itemize}
%\end{frame}


%\begin{frame}
%Transacciones y Sub-transacciones son No Bloqueantes.

%Base de la Concurrencia:
%  \begin{itemize}
%  \item A cada hilo, copia del objeto
%  \item Al cerrar transacción, se sincronizan las copias
%  \item Si dos hilos cierran transacción muy próximos,

% tal vez el segundo no pueda
%  \end{itemize}
%\end{frame}

%\begin{frame}
%Persistencia
%  \begin{itemize}
%  \item Cada objeto tiene identificador único y persistente
%  \item Todo objeto persistente debe heredar de determinada clase
%  \item Todos los sub-objetos de un objeto persistente deben ser
%persistentes o no cambiar
%  \item La persistencia supone penalización en eficiencia
%  \end{itemize}
%\end{frame}














\begin{frame}
\frametitle{Objetos en Python}

Todo son objetos, en sentido amplio:
\begin{itemize}
\item Cualquier objeto puede ser asignado a una variable o pasado como
  parámetro a una función
\item Algunos objetos pueden no tener ni atributos ni métodos
\item Algunos objetos pueden no permitir que se herede de ellos
\end{itemize}

Ejemplos de objetos Python: Strings, listas, funciones, módulos\ldots
\end{frame}


\begin{frame}[fragile]



Todos los objetos tienen:
\begin{itemize}
\item {\bf Identidad}: 
  \begin{footnotesize}
    \begin{itemize}
    \item Nunca cambia. 
    \item El operador \verb|is| compara la identidad de dos objetos.
    \item La función \verb|id()| devuelve una representación de la
      identidad (actualmente, su dirección de memoria).
  \end{itemize}
\end{footnotesize}
\item {\bf Tipo}:
  \begin{footnotesize}
    \begin{itemize}
    \item Nunca cambia.
    \item La función \verb|type()| devuelve el tipo de un objeto (que
      es otro objeto) 
    \end{itemize}
  \end{footnotesize}
\item {\bf Valor}:
  \begin{footnotesize}
    \begin{itemize}
    \item Objetos inmutables: su valor no puede cambiar
    \item Objetos mutables: su valor puede cambiar
    \end{itemize}
  \end{footnotesize}
\end{itemize}
{\bf Contenedores}: objetos que contienen referencias a otros objetos
(ej.: tuplas, listas, diccionarios).

\end{frame}


\begin{frame}[fragile]
\frametitle{Cadenas de documentación}

\begin{small}
\begin{itemize}
\item No son obligatorias pero sí muy recomendables (varias
  herramientas hacen uso de ellas).
\item La cadena de documentación de un objeto es su atributo
  \verb|__doc__|
\item En una sola línea para objetos sencillos, en varias para el
  resto de los casos.
\item Entre triples comillas-dobles (incluso si ocupan una línea).
\item Si hay varias líneas:
  \begin{itemize}
  \item La primera línea debe ser una resumen breve del propósito del
    objeto. Debe empezar con mayúscula y acabar con un punto
  \item Una línea en blanco debe separar la primera línea del resto
  \item Las siguientes líneas deberían empezar justo debajo de la
    primera comilla doble de la primera línea
\end{itemize}
\end{itemize}
\end{small}
\end{frame}



\begin{frame}[fragile]

De una sola línea:
\begin{small}
\begin{verbatim}
def kos_root():
    """Return the pathname of the KOS root directory."""
    global _kos_root
    ...
\end{verbatim}
\end{small}

De varias:
\begin{small}
\begin{verbatim}
def complex(real=0.0, imag=0.0):
    """Form a complex number.

    Keyword arguments:
    real -- the real part (default 0.0)
    imag -- the imaginary part (default 0.0)

    """
    if imag == 0.0 and real == 0.0: return complex_zero
\end{verbatim}
\end{small}
  
\end{frame}


\begin{frame}
\frametitle{Documentando el código (tipo Javadoc)}

\begin{small}
\begin{itemize}
\item Permite documentar el código -generalmente las funciones- dentro del propio código
\item Genera la documentación del código en formatos legibles y navegables
(HTML, PDF...)
\item Se basa en un lenguaje de marcado simple
\item PERO... hay que mantener la documentación al día cuando se cambia
el código
\end{itemize}
\end{small}
\end{frame}

\begin{frame}[fragile]
Ejemplo

\begin{small}
\begin{verbatim}
def interseccion(m, b):
  """
  Devuelve la interseccion de la curva M{y=m*x+b} con el eje X. 
  Se trata del punto en el que la curva cruza el eje X (M{y=0}).

  @type  m: número
  @param m: La pendiente de la curva
  @type  b: número
  @param b: La intersección con el eje Y

  @rtype:   número
  @return:  la interseccíoin con el eje X de la curva M{y=m*x+b}.
  """
  return -b/m
\end{verbatim}
\end{small}
  
\end{frame}


